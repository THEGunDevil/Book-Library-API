package handlers

import (
	"log"
	"net/http"

	"github.com/THEGunDevil/GoForBackend/internal/db"
	gen "github.com/THEGunDevil/GoForBackend/internal/db/gen"
	"github.com/THEGunDevil/GoForBackend/internal/models"
	"github.com/THEGunDevil/GoForBackend/internal/service"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

// =======================
// Payments Handlers
func CreatePaymentHandler(c *gin.Context) {	
	var req models.CreatePaymentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payload", "details": err.Error()})
		return
	}

	if req.UserID == uuid.Nil || req.PlanID == uuid.Nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "user_id and plan_id are required"})
		return
	}

	ctx := c.Request.Context()

	// Fetch plan details
	plan, err := db.Q.GetSubscriptionPlanByID(ctx, pgtype.UUID{Bytes: req.PlanID, Valid: true})
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid plan_id"})
		return
	}

	// Insert pending payment; transaction_id will be auto-generated by Postgres
	params := gen.CreatePaymentParams{
		UserID:         pgtype.UUID{Bytes: req.UserID, Valid: true},
		PlanID:         pgtype.UUID{Bytes: req.PlanID, Valid: true},
		Amount:         float64(plan.Price),
		Currency:       "USD",
		PaymentGateway: pgtype.Text{String: "stripe", Valid: true},
	}

	payment, err := db.Q.CreatePayment(ctx, params)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create payment", "details": err.Error()})
		return
	}

	log.Printf("Payment created: id=%s, transaction_id=%s, amount=%f %s",
		payment.ID, payment.TransactionID, payment.Amount, payment.Currency)

	// Initialize Stripe payment
	redirectURL, err := service.InitializeStripePayment(&payment)
	if err != nil {
		log.Println("Stripe session creation failed:", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "failed to initialize payment gateway",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":        "payment session created",
		"payment_id":     payment.ID,
		"transaction_id": payment.TransactionID,
		"redirect_url":   redirectURL,
	})
}

func GetPaymentHandler(c *gin.Context) {
	idStr := c.Param("id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payment ID"})
		return
	}

	payment, err := db.Q.GetPaymentByID(c.Request.Context(), pgtype.UUID{Bytes: id, Valid: true})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get payment", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"payment": payment})
}

func ListPaymentsByUserHandler(c *gin.Context) {
	userIDStr := c.Param("user_id")
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user ID"})
		return
	}

	payments, err := db.Q.ListPaymentsByUser(c.Request.Context(), pgtype.UUID{Bytes: userID, Valid: true})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list payments", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"payments": payments})
}

func UpdatePaymentStatusHandler(c *gin.Context) {
	idStr := c.Param("id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payment ID"})
		return
	}

	var req struct {
		Status string `json:"status"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload", "details": err.Error()})
		return
	}

	// Validate status
	validStatuses := map[string]bool{"paid": true, "failed": true, "pending": true}
	if !validStatuses[req.Status] {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid status value"})
		return
	}

	params := gen.UpdatePaymentStatusParams{
		ID:     pgtype.UUID{Bytes: id, Valid: true},
		Status: req.Status,
	}

	payment, err := db.Q.UpdatePaymentStatus(c.Request.Context(), params)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update payment status", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"payment": payment})
}

func DeletePaymentByIDHandler(c *gin.Context) {
	idStr := c.Param("id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payment ID"})
		return
	}

	if err := db.Q.DeletePayment(c.Request.Context(), pgtype.UUID{Bytes: id, Valid: true}); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete payment", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "payment deleted"})
}
