package handlers

import (
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/THEGunDevil/GoForBackend/internal/db"
	gen "github.com/THEGunDevil/GoForBackend/internal/db/gen"
	"github.com/THEGunDevil/GoForBackend/internal/models"
	"github.com/THEGunDevil/GoForBackend/internal/service"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

// =======================
// Payments Handlers
func CreatePaymentHandler(c *gin.Context) {
	var req models.CreatePaymentRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payload", "details": err.Error()})
		return
	}

	if req.UserID == uuid.Nil || req.PlanID == uuid.Nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "user_id and plan_id are required"})
		return
	}

	ctx := c.Request.Context()

	// Fetch plan details
	plan, err := db.Q.GetSubscriptionPlanByID(ctx, pgtype.UUID{Bytes: req.PlanID, Valid: true})
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid plan_id"})
		return
	}

	// Insert pending payment; transaction_id will be auto-generated by Postgres
	params := gen.CreatePaymentParams{
		UserID:         pgtype.UUID{Bytes: req.UserID, Valid: true},
		PlanID:         pgtype.UUID{Bytes: req.PlanID, Valid: true},
		Amount:         float64(plan.Price),
		Currency:       "USD",
		PaymentGateway: pgtype.Text{String: "stripe", Valid: true},
	}

	payment, err := db.Q.CreatePayment(ctx, params)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create payment", "details": err.Error()})
		return
	}

	log.Printf("Payment created: id=%s, transaction_id=%s, amount=%f %s",
		payment.ID, payment.TransactionID, payment.Amount, payment.Currency)

	// Initialize Stripe payment
	redirectURL, err := service.InitializeStripePayment(&payment)
	if err != nil {
		log.Println("Stripe session creation failed:", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "failed to initialize payment gateway",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":        "payment session created",
		"payment_id":     payment.ID,
		"transaction_id": payment.TransactionID,
		"redirect_url":   redirectURL,
	})
}

func GetPaymentHandler(c *gin.Context) {
	idStr := c.Param("id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payment ID"})
		return
	}

	payment, err := db.Q.GetPaymentByID(c.Request.Context(), pgtype.UUID{Bytes: id, Valid: true})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get payment", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"payment": payment})
}

func ListAllPaymentsHandler(c *gin.Context) {
	// Pagination params (default: page 1, limit 20)
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
	if page < 1 {
		page = 1
	}
	if limit < 1 || limit > 100 {
		limit = 20
	}
	offset := (page - 1) * limit

	// Fetch payments with sorting and pagination
	payments, err := db.Q.GetAllPayments(c.Request.Context(), gen.GetAllPaymentsParams{Limit: int32(limit), Offset: int32(offset)})
	if err != nil {
		// Log error, e.g., log.Println("Error fetching payments:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list payments"})
		return
	}

	var response []models.DashboardPaymentResponse
	for _, r := range payments {
		refunds, err := db.Q.GetRefundByPaymentID(c.Request.Context(), r.ID) // map[uuid.UUID]Refund
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to fetch refunds"})
			return
		}
		users, err := db.Q.GetUserByID(c.Request.Context(), r.UserID) // map[uuid.UUID]User
		if err != nil {
			// Log error
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to fetch users"})
			return
		}
		username := users.FirstName + "" + users.LastName
		var subscriptionID *uuid.UUID
		if r.SubscriptionID.Valid {
			u, err := uuid.FromBytes(r.SubscriptionID.Bytes[:])
			if err == nil {
				subscriptionID = &u
			}
		}

		// Default refund fields
		var refundStatus, refundReason string
		var requestedAt time.Time
		var processedAt *time.Time

		if refunds.PaymentID == r.ID { // only mark if it matches payment
			refundStatus = refunds.Status
			refundReason = refunds.Reason.String
			requestedAt = refunds.RequestedAt.Time
			if !refunds.ProcessedAt.Valid {
				processedAt = &refunds.ProcessedAt.Time
			}
		}

		response = append(response, models.DashboardPaymentResponse{
			ID:             r.ID.Bytes,
			UserID:         r.UserID.Bytes,
			SubscriptionID: subscriptionID,
			Amount:         r.Amount,
			Currency:       r.Currency,
			TransactionID:  r.TransactionID.Bytes,
			PaymentGateway: r.PaymentGateway.String,
			Status:         r.Status,
			CreatedAt:      r.CreatedAt.Time,
			RefundStatus:   refundStatus,
			RefundReason:   refundReason,
			RequestedAt:    requestedAt,
			ProcessedAt:    processedAt,
			UserName:       username,
		})
	}

	// Optional metadata
	totalPayments, err := db.Q.CountPayments(c.Request.Context())
	if err != nil {
		// Log error
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to count payments"})
		return
	}
	c.JSON(http.StatusOK, gin.H{
		"payments": response,
		"metadata": gin.H{
			"total": totalPayments,
			"page":  page,
			"limit": limit,
		},
	})
}
func UpdatePaymentStatusHandler(c *gin.Context) {
	idStr := c.Param("id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payment ID"})
		return
	}

	var req struct {
		Status string `json:"status"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload", "details": err.Error()})
		return
	}

	// Validate status
	validStatuses := map[string]bool{"paid": true, "failed": true, "pending": true}
	if !validStatuses[req.Status] {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid status value"})
		return
	}

	params := gen.UpdatePaymentStatusParams{
		ID:     pgtype.UUID{Bytes: id, Valid: true},
		Status: req.Status,
	}

	payment, err := db.Q.UpdatePaymentStatus(c.Request.Context(), params)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update payment status", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"payment": payment})
}

func DeletePaymentByIDHandler(c *gin.Context) {
	idStr := c.Param("id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payment ID"})
		return
	}

	if err := db.Q.DeletePayment(c.Request.Context(), pgtype.UUID{Bytes: id, Valid: true}); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete payment", "details": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "payment deleted"})
}
