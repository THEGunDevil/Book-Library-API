// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: books.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBook = `-- name: CreateBook :one
INSERT INTO books (title, author, published_year, isbn, total_copies, available_copies, image_url, genre, description)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, title, author, description, genre, published_year, isbn, available_copies, total_copies, created_at, updated_at, image_url
`

type CreateBookParams struct {
	Title           string
	Author          string
	PublishedYear   pgtype.Int4
	Isbn            pgtype.Text
	TotalCopies     int32
	AvailableCopies pgtype.Int4
	ImageUrl        string
	Genre           string
	Description     string
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRow(ctx, createBook,
		arg.Title,
		arg.Author,
		arg.PublishedYear,
		arg.Isbn,
		arg.TotalCopies,
		arg.AvailableCopies,
		arg.ImageUrl,
		arg.Genre,
		arg.Description,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Description,
		&i.Genre,
		&i.PublishedYear,
		&i.Isbn,
		&i.AvailableCopies,
		&i.TotalCopies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
	)
	return i, err
}

const decrementAvailableCopiesByID = `-- name: DecrementAvailableCopiesByID :one
UPDATE books
SET available_copies = available_copies - 1
WHERE id = $1 AND available_copies > 0
RETURNING available_copies
`

func (q *Queries) DecrementAvailableCopiesByID(ctx context.Context, id pgtype.UUID) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, decrementAvailableCopiesByID, id)
	var available_copies pgtype.Int4
	err := row.Scan(&available_copies)
	return available_copies, err
}

const deleteBookByID = `-- name: DeleteBookByID :one
DELETE FROM books
WHERE id = $1
RETURNING id, title, author, description, genre, published_year, isbn, available_copies, total_copies, created_at, updated_at, image_url
`

func (q *Queries) DeleteBookByID(ctx context.Context, id pgtype.UUID) (Book, error) {
	row := q.db.QueryRow(ctx, deleteBookByID, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Description,
		&i.Genre,
		&i.PublishedYear,
		&i.Isbn,
		&i.AvailableCopies,
		&i.TotalCopies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
	)
	return i, err
}

const getBookByID = `-- name: GetBookByID :one
SELECT id, title, author, description, genre, published_year, isbn, available_copies, total_copies, created_at, updated_at, image_url FROM books
WHERE id = $1
`

func (q *Queries) GetBookByID(ctx context.Context, id pgtype.UUID) (Book, error) {
	row := q.db.QueryRow(ctx, getBookByID, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Description,
		&i.Genre,
		&i.PublishedYear,
		&i.Isbn,
		&i.AvailableCopies,
		&i.TotalCopies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
	)
	return i, err
}

const incrementAvailableCopiesByID = `-- name: IncrementAvailableCopiesByID :one
UPDATE books
SET available_copies = available_copies + 1
WHERE id = $1
RETURNING available_copies
`

func (q *Queries) IncrementAvailableCopiesByID(ctx context.Context, id pgtype.UUID) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, incrementAvailableCopiesByID, id)
	var available_copies pgtype.Int4
	err := row.Scan(&available_copies)
	return available_copies, err
}

const listBooks = `-- name: ListBooks :many
SELECT id, title, author, description, genre, published_year, isbn, available_copies, total_copies, created_at, updated_at, image_url FROM books
ORDER BY created_at DESC
`

func (q *Queries) ListBooks(ctx context.Context) ([]Book, error) {
	rows, err := q.db.Query(ctx, listBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Description,
			&i.Genre,
			&i.PublishedYear,
			&i.Isbn,
			&i.AvailableCopies,
			&i.TotalCopies,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGenres = `-- name: ListGenres :many
SELECT DISTINCT genre
FROM books
WHERE genre IS NOT NULL AND genre <> ''
ORDER BY genre
`

func (q *Queries) ListGenres(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var genre string
		if err := rows.Scan(&genre); err != nil {
			return nil, err
		}
		items = append(items, genre)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBooks = `-- name: SearchBooks :many
SELECT
    id,
    title,
    author,
    genre,
    published_year,
    isbn,
    available_copies,
    total_copies,
    description,
    image_url,
    created_at,
    updated_at
FROM books
WHERE
    ($1::text IS NULL OR genre ILIKE '%' || $1 || '%')
    AND ($2::text IS NULL OR title ILIKE '%' || $2 || '%' OR author ILIKE '%' || $2 || '%')
ORDER BY title
`

type SearchBooksParams struct {
	Column1 string
	Column2 string
}

type SearchBooksRow struct {
	ID              pgtype.UUID
	Title           string
	Author          string
	Genre           string
	PublishedYear   pgtype.Int4
	Isbn            pgtype.Text
	AvailableCopies pgtype.Int4
	TotalCopies     int32
	Description     string
	ImageUrl        string
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) SearchBooks(ctx context.Context, arg SearchBooksParams) ([]SearchBooksRow, error) {
	rows, err := q.db.Query(ctx, searchBooks, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchBooksRow
	for rows.Next() {
		var i SearchBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Genre,
			&i.PublishedYear,
			&i.Isbn,
			&i.AvailableCopies,
			&i.TotalCopies,
			&i.Description,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookByID = `-- name: UpdateBookByID :one
UPDATE books
SET
  title = COALESCE($2, title),
  author = COALESCE($3, author),
  published_year = COALESCE($4, published_year),
  isbn = COALESCE($5, isbn),
  total_copies = COALESCE($6, total_copies),
  available_copies = COALESCE($7, available_copies),
  genre = COALESCE($8, genre),
  description = COALESCE($9, description),
  updated_at = NOW()
WHERE id = $1
RETURNING id, title, author, description, genre, published_year, isbn, available_copies, total_copies, created_at, updated_at, image_url
`

type UpdateBookByIDParams struct {
	ID              pgtype.UUID
	Title           string
	Author          string
	PublishedYear   pgtype.Int4
	Isbn            pgtype.Text
	TotalCopies     int32
	AvailableCopies pgtype.Int4
	Genre           string
	Description     string
}

func (q *Queries) UpdateBookByID(ctx context.Context, arg UpdateBookByIDParams) (Book, error) {
	row := q.db.QueryRow(ctx, updateBookByID,
		arg.ID,
		arg.Title,
		arg.Author,
		arg.PublishedYear,
		arg.Isbn,
		arg.TotalCopies,
		arg.AvailableCopies,
		arg.Genre,
		arg.Description,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Description,
		&i.Genre,
		&i.PublishedYear,
		&i.Isbn,
		&i.AvailableCopies,
		&i.TotalCopies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
	)
	return i, err
}
