// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: books.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countBooks = `-- name: CountBooks :one
SELECT COUNT(*) FROM books
`

func (q *Queries) CountBooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countBooks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchBooks = `-- name: CountSearchBooks :one
SELECT COUNT(*)
FROM books
WHERE
    (CASE 
        WHEN $1 = '' OR $1 = 'all' THEN TRUE
        ELSE genre ILIKE '%' || $1 || '%'
    END)
    AND (
        title ILIKE '%' || $2 || '%' 
        OR author ILIKE '%' || $2 || '%'
        OR description ILIKE '%' || $2 || '%'
    )
`

type CountSearchBooksParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 pgtype.Text `json:"column_2"`
}

func (q *Queries) CountSearchBooks(ctx context.Context, arg CountSearchBooksParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchBooks, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBook = `-- name: CreateBook :one
INSERT INTO books (title, author, published_year, isbn, total_copies, image_url, genre, description)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, title, author, description, genre, published_year, isbn, total_copies, available_copies, created_at, updated_at, image_url
`

type CreateBookParams struct {
	Title         string      `json:"title"`
	Author        string      `json:"author"`
	PublishedYear pgtype.Int4 `json:"published_year"`
	Isbn          pgtype.Text `json:"isbn"`
	TotalCopies   int32       `json:"total_copies"`
	ImageUrl      string      `json:"image_url"`
	Genre         string      `json:"genre"`
	Description   string      `json:"description"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRow(ctx, createBook,
		arg.Title,
		arg.Author,
		arg.PublishedYear,
		arg.Isbn,
		arg.TotalCopies,
		arg.ImageUrl,
		arg.Genre,
		arg.Description,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Description,
		&i.Genre,
		&i.PublishedYear,
		&i.Isbn,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
	)
	return i, err
}

const decrementAvailableCopiesByID = `-- name: DecrementAvailableCopiesByID :one
UPDATE books
SET available_copies = available_copies - 1
WHERE id = $1 AND available_copies > 0
RETURNING available_copies
`

func (q *Queries) DecrementAvailableCopiesByID(ctx context.Context, id pgtype.UUID) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, decrementAvailableCopiesByID, id)
	var available_copies pgtype.Int4
	err := row.Scan(&available_copies)
	return available_copies, err
}

const deleteBookByID = `-- name: DeleteBookByID :one
DELETE FROM books
WHERE id = $1
RETURNING id, title, author, description, genre, published_year, isbn, total_copies, available_copies, created_at, updated_at, image_url
`

func (q *Queries) DeleteBookByID(ctx context.Context, id pgtype.UUID) (Book, error) {
	row := q.db.QueryRow(ctx, deleteBookByID, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Description,
		&i.Genre,
		&i.PublishedYear,
		&i.Isbn,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
	)
	return i, err
}

const filterBooksByGenre = `-- name: FilterBooksByGenre :many
SELECT id, title, author, description, genre, published_year, isbn, total_copies, available_copies, created_at, updated_at, image_url FROM books
WHERE genre = $1
`

func (q *Queries) FilterBooksByGenre(ctx context.Context, genre string) ([]Book, error) {
	rows, err := q.db.Query(ctx, filterBooksByGenre, genre)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Description,
			&i.Genre,
			&i.PublishedYear,
			&i.Isbn,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookByID = `-- name: GetBookByID :one
SELECT id, title, author, description, genre, published_year, isbn, total_copies, available_copies, created_at, updated_at, image_url FROM books
WHERE id = $1
`

func (q *Queries) GetBookByID(ctx context.Context, id pgtype.UUID) (Book, error) {
	row := q.db.QueryRow(ctx, getBookByID, id)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Description,
		&i.Genre,
		&i.PublishedYear,
		&i.Isbn,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
	)
	return i, err
}

const incrementAvailableCopiesByID = `-- name: IncrementAvailableCopiesByID :one
UPDATE books
SET available_copies = available_copies + 1
WHERE id = $1
RETURNING available_copies
`

func (q *Queries) IncrementAvailableCopiesByID(ctx context.Context, id pgtype.UUID) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, incrementAvailableCopiesByID, id)
	var available_copies pgtype.Int4
	err := row.Scan(&available_copies)
	return available_copies, err
}

const listBooksPaginated = `-- name: ListBooksPaginated :many
SELECT id, title, author, description, genre, published_year, isbn, total_copies, available_copies, created_at, updated_at, image_url
FROM books
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListBooksPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBooksPaginated(ctx context.Context, arg ListBooksPaginatedParams) ([]Book, error) {
	rows, err := q.db.Query(ctx, listBooksPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Description,
			&i.Genre,
			&i.PublishedYear,
			&i.Isbn,
			&i.TotalCopies,
			&i.AvailableCopies,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGenres = `-- name: ListGenres :many
SELECT DISTINCT genre
FROM books
WHERE genre IS NOT NULL AND genre <> ''
ORDER BY genre
`

func (q *Queries) ListGenres(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var genre string
		if err := rows.Scan(&genre); err != nil {
			return nil, err
		}
		items = append(items, genre)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBooks = `-- name: SearchBooks :many
SELECT
    id,
    title,
    author,
    genre,
    published_year,
    isbn,
    available_copies,
    total_copies,
    description,
    image_url,
    created_at,
    updated_at
FROM books
WHERE
    ($1::text IS NULL OR genre ILIKE '%' || $1 || '%')
    AND ($2::text IS NULL OR title ILIKE '%' || $2 || '%' OR author ILIKE '%' || $2 || '%')
ORDER BY title
LIMIT $3
OFFSET $4
`

type SearchBooksParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type SearchBooksRow struct {
	ID              pgtype.UUID      `json:"id"`
	Title           string           `json:"title"`
	Author          string           `json:"author"`
	Genre           string           `json:"genre"`
	PublishedYear   pgtype.Int4      `json:"published_year"`
	Isbn            pgtype.Text      `json:"isbn"`
	AvailableCopies pgtype.Int4      `json:"available_copies"`
	TotalCopies     int32            `json:"total_copies"`
	Description     string           `json:"description"`
	ImageUrl        string           `json:"image_url"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) SearchBooks(ctx context.Context, arg SearchBooksParams) ([]SearchBooksRow, error) {
	rows, err := q.db.Query(ctx, searchBooks,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchBooksRow
	for rows.Next() {
		var i SearchBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Genre,
			&i.PublishedYear,
			&i.Isbn,
			&i.AvailableCopies,
			&i.TotalCopies,
			&i.Description,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBooksWithPagination = `-- name: SearchBooksWithPagination :many
SELECT
    id,
    title,
    author,
    genre,
    published_year,
    isbn,
    available_copies,
    total_copies,
    description,
    image_url,
    created_at,
    updated_at
FROM books
WHERE
    (CASE 
        WHEN $1 = '' OR $1 = 'all' THEN TRUE
        ELSE genre ILIKE '%' || $1 || '%'
    END)
    AND (
        title ILIKE '%' || $2 || '%' 
        OR author ILIKE '%' || $2 || '%'
        OR description ILIKE '%' || $2 || '%'
    )
ORDER BY title
LIMIT $3
OFFSET $4
`

type SearchBooksWithPaginationParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchBooksWithPaginationRow struct {
	ID              pgtype.UUID      `json:"id"`
	Title           string           `json:"title"`
	Author          string           `json:"author"`
	Genre           string           `json:"genre"`
	PublishedYear   pgtype.Int4      `json:"published_year"`
	Isbn            pgtype.Text      `json:"isbn"`
	AvailableCopies pgtype.Int4      `json:"available_copies"`
	TotalCopies     int32            `json:"total_copies"`
	Description     string           `json:"description"`
	ImageUrl        string           `json:"image_url"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) SearchBooksWithPagination(ctx context.Context, arg SearchBooksWithPaginationParams) ([]SearchBooksWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, searchBooksWithPagination,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchBooksWithPaginationRow
	for rows.Next() {
		var i SearchBooksWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Author,
			&i.Genre,
			&i.PublishedYear,
			&i.Isbn,
			&i.AvailableCopies,
			&i.TotalCopies,
			&i.Description,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookByID = `-- name: UpdateBookByID :one
UPDATE books
SET
    title = COALESCE($1, title),
    author = COALESCE($2, author),
    published_year = COALESCE($3, published_year),
    isbn = COALESCE($4, isbn),
    available_copies = COALESCE($5, available_copies),
    total_copies = COALESCE($6, total_copies),
    genre = COALESCE($7, genre),
    description = COALESCE($8, description),
    image_url = COALESCE($9, image_url),
    updated_at = NOW()
WHERE id = $10
RETURNING id, title, author, description, genre, published_year, isbn, total_copies, available_copies, created_at, updated_at, image_url
`

type UpdateBookByIDParams struct {
	Title           pgtype.Text `json:"title"`
	Author          pgtype.Text `json:"author"`
	PublishedYear   pgtype.Int4 `json:"published_year"`
	Isbn            pgtype.Text `json:"isbn"`
	AvailableCopies pgtype.Int4 `json:"available_copies"`
	TotalCopies     pgtype.Int4 `json:"total_copies"`
	Genre           pgtype.Text `json:"genre"`
	Description     pgtype.Text `json:"description"`
	ImageUrl        pgtype.Text `json:"image_url"`
	ID              pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateBookByID(ctx context.Context, arg UpdateBookByIDParams) (Book, error) {
	row := q.db.QueryRow(ctx, updateBookByID,
		arg.Title,
		arg.Author,
		arg.PublishedYear,
		arg.Isbn,
		arg.AvailableCopies,
		arg.TotalCopies,
		arg.Genre,
		arg.Description,
		arg.ImageUrl,
		arg.ID,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Author,
		&i.Description,
		&i.Genre,
		&i.PublishedYear,
		&i.Isbn,
		&i.TotalCopies,
		&i.AvailableCopies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImageUrl,
	)
	return i, err
}
