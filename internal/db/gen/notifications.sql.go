// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notifications.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignNotificationToUser = `-- name: AssignNotificationToUser :exec
INSERT INTO user_notification_status (
    user_id, event_id, is_read, read_at, created_at
) VALUES (
    $1, $2, false, NULL, NOW()
)
ON CONFLICT (user_id, event_id) DO NOTHING
`

type AssignNotificationToUserParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	EventID pgtype.UUID `json:"event_id"`
}

// Use this for TARGETED notifications (Direct Messages). It forces is_read = false.
func (q *Queries) AssignNotificationToUser(ctx context.Context, arg AssignNotificationToUserParams) error {
	_, err := q.db.Exec(ctx, assignNotificationToUser, arg.UserID, arg.EventID)
	return err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    object_id,
    object_title,
    type,
    title,
    message,
    metadata,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, NOW()
)
RETURNING id, object_id, object_title, type, title, message, metadata, created_at
`

type CreateEventParams struct {
	ObjectID    pgtype.UUID `json:"object_id"`
	ObjectTitle pgtype.Text `json:"object_title"`
	Type        string      `json:"type"`
	Title       string      `json:"title"`
	Message     string      `json:"message"`
	Metadata    []byte      `json:"metadata"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.ObjectID,
		arg.ObjectTitle,
		arg.Type,
		arg.Title,
		arg.Message,
		arg.Metadata,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ObjectID,
		&i.ObjectTitle,
		&i.Type,
		&i.Title,
		&i.Message,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getUserNotificationsByUserID = `-- name: GetUserNotificationsByUserID :many
SELECT 
    e.id AS event_id,
    e.object_id,
    e.object_title,
    e.type,
    e.title AS notification_title,
    e.message,
    e.metadata,
    e.created_at,
    COALESCE(uns.is_read, false) AS is_read,
    uns.read_at
FROM events e
JOIN users u ON u.id = $1
LEFT JOIN user_notification_status uns 
    ON e.id = uns.event_id AND uns.user_id = $1
WHERE 
    e.created_at >= u.created_at
    OR uns.user_id IS NOT NULL
ORDER BY e.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserNotificationsByUserIDParams struct {
	ID     pgtype.UUID `json:"id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetUserNotificationsByUserIDRow struct {
	EventID           pgtype.UUID      `json:"event_id"`
	ObjectID          pgtype.UUID      `json:"object_id"`
	ObjectTitle       pgtype.Text      `json:"object_title"`
	Type              string           `json:"type"`
	NotificationTitle string           `json:"notification_title"`
	Message           string           `json:"message"`
	Metadata          []byte           `json:"metadata"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	IsRead            bool             `json:"is_read"`
	ReadAt            pgtype.Timestamp `json:"read_at"`
}

func (q *Queries) GetUserNotificationsByUserID(ctx context.Context, arg GetUserNotificationsByUserIDParams) ([]GetUserNotificationsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getUserNotificationsByUserID, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserNotificationsByUserIDRow
	for rows.Next() {
		var i GetUserNotificationsByUserIDRow
		if err := rows.Scan(
			&i.EventID,
			&i.ObjectID,
			&i.ObjectTitle,
			&i.Type,
			&i.NotificationTitle,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
			&i.IsRead,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllNotificationsAsRead = `-- name: MarkAllNotificationsAsRead :exec
INSERT INTO user_notification_status (user_id, event_id, is_read, read_at, created_at)
SELECT 
    $1, e.id, true, NOW(), NOW()
FROM events e
JOIN users u ON u.id = $1
LEFT JOIN user_notification_status uns ON e.id = uns.event_id AND uns.user_id = $1
WHERE 
    (e.created_at >= u.created_at OR uns.user_id IS NOT NULL)
    AND COALESCE(uns.is_read, false) = false
ON CONFLICT (user_id, event_id) 
DO UPDATE SET is_read = true, read_at = NOW()
`

func (q *Queries) MarkAllNotificationsAsRead(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markAllNotificationsAsRead, userID)
	return err
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :exec
INSERT INTO user_notification_status (user_id, event_id, is_read, read_at, created_at)
VALUES ($1, $2, true, NOW(), NOW())
ON CONFLICT (user_id, event_id)
DO UPDATE SET is_read = true, read_at = NOW()
`

type MarkNotificationAsReadParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	EventID pgtype.UUID `json:"event_id"`
}

// Use this when a user clicks a notification.
func (q *Queries) MarkNotificationAsRead(ctx context.Context, arg MarkNotificationAsReadParams) error {
	_, err := q.db.Exec(ctx, markNotificationAsRead, arg.UserID, arg.EventID)
	return err
}
