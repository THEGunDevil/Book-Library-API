// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notifications.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    object_id,
    object_title,
    type,
    title,
    message,
    metadata,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, NOW()
)
RETURNING id, object_id, object_title, type, title, message, metadata, created_at
`

type CreateEventParams struct {
	ObjectID    pgtype.UUID `json:"object_id"`
	ObjectTitle pgtype.Text `json:"object_title"`
	Type        string      `json:"type"`
	Title       string      `json:"title"`
	Message     string      `json:"message"`
	Metadata    []byte      `json:"metadata"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.ObjectID,
		arg.ObjectTitle,
		arg.Type,
		arg.Title,
		arg.Message,
		arg.Metadata,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ObjectID,
		&i.ObjectTitle,
		&i.Type,
		&i.Title,
		&i.Message,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getUserNotificationsByUserID = `-- name: GetUserNotificationsByUserID :many
SELECT
    e.id AS event_id,
    e.object_id,
    e.object_title,
    e.type,
    e.title AS notification_title,
    e.message,
    e.metadata,
    e.created_at,
    COALESCE(uns.is_read, false) AS is_read,
    uns.read_at
FROM events e
LEFT JOIN user_notification_status uns
    ON e.id = uns.event_id
    AND uns.user_id = $1
ORDER BY e.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserNotificationsByUserIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetUserNotificationsByUserIDRow struct {
	EventID           pgtype.UUID      `json:"event_id"`
	ObjectID          pgtype.UUID      `json:"object_id"`
	ObjectTitle       pgtype.Text      `json:"object_title"`
	Type              string           `json:"type"`
	NotificationTitle string           `json:"notification_title"`
	Message           string           `json:"message"`
	Metadata          []byte           `json:"metadata"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	IsRead            bool             `json:"is_read"`
	ReadAt            pgtype.Timestamp `json:"read_at"`
}

func (q *Queries) GetUserNotificationsByUserID(ctx context.Context, arg GetUserNotificationsByUserIDParams) ([]GetUserNotificationsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getUserNotificationsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserNotificationsByUserIDRow
	for rows.Next() {
		var i GetUserNotificationsByUserIDRow
		if err := rows.Scan(
			&i.EventID,
			&i.ObjectID,
			&i.ObjectTitle,
			&i.Type,
			&i.NotificationTitle,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
			&i.IsRead,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUnreadEventsForUser = `-- name: SelectUnreadEventsForUser :many
SELECT e.id
FROM events e
LEFT JOIN user_notification_status uns
  ON e.id = uns.event_id AND uns.user_id = $1
WHERE COALESCE(uns.is_read, false) = false
`

func (q *Queries) SelectUnreadEventsForUser(ctx context.Context, userID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, selectUnreadEventsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertUserNotificationStatus = `-- name: UpsertUserNotificationStatus :exec
INSERT INTO user_notification_status (user_id, event_id, is_read, read_at, created_at)
VALUES ($1, $2, true, NOW(), NOW())
ON CONFLICT (user_id, event_id)
DO UPDATE SET is_read = true, read_at = NOW()
`

type UpsertUserNotificationStatusParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	EventID pgtype.UUID `json:"event_id"`
}

func (q *Queries) UpsertUserNotificationStatus(ctx context.Context, arg UpsertUserNotificationStatusParams) error {
	_, err := q.db.Exec(ctx, upsertUserNotificationStatus, arg.UserID, arg.EventID)
	return err
}
