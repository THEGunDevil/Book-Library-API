// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: overview.sql

package db

import (
	"context"
)

const getBooksPerMonth = `-- name: GetBooksPerMonth :many
SELECT TO_CHAR(created_at, 'Mon') AS month,
       COUNT(*) AS books
FROM books
WHERE created_at >= NOW() - INTERVAL '6 months'
GROUP BY month
ORDER BY MIN(created_at)
`

type GetBooksPerMonthRow struct {
	Month string `json:"month"`
	Books int64  `json:"books"`
}

func (q *Queries) GetBooksPerMonth(ctx context.Context) ([]GetBooksPerMonthRow, error) {
	rows, err := q.db.Query(ctx, getBooksPerMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBooksPerMonthRow
	for rows.Next() {
		var i GetBooksPerMonthRow
		if err := rows.Scan(&i.Month, &i.Books); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryData = `-- name: GetCategoryData :many
SELECT genre AS name,
       COUNT(*) AS value
FROM books
GROUP BY genre
`

type GetCategoryDataRow struct {
	Name  string `json:"name"`
	Value int64  `json:"value"`
}

func (q *Queries) GetCategoryData(ctx context.Context) ([]GetCategoryDataRow, error) {
	rows, err := q.db.Query(ctx, getCategoryData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoryDataRow
	for rows.Next() {
		var i GetCategoryDataRow
		if err := rows.Scan(&i.Name, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStats = `-- name: GetStats :one
SELECT
    (SELECT COUNT(*) FROM books) AS total_books,
    (SELECT COUNT(*) FROM users WHERE role='member') AS active_users,
    (SELECT COUNT(*) FROM subscriptions WHERE status='active') AS total_subscriptions,
    (SELECT COALESCE(SUM(p.amount),0)
     FROM payments p
     WHERE p.status='paid'
       AND EXTRACT(MONTH FROM p.created_at) = CAST($1 AS INT)
       AND EXTRACT(YEAR FROM p.created_at) = CAST($2 AS INT)
    ) AS revenue_month
`

type GetStatsParams struct {
	Column1 int32 `json:"column_1"`
	Column2 int32 `json:"column_2"`
}

type GetStatsRow struct {
	TotalBooks         int64       `json:"total_books"`
	ActiveUsers        int64       `json:"active_users"`
	TotalSubscriptions int64       `json:"total_subscriptions"`
	RevenueMonth       interface{} `json:"revenue_month"`
}

func (q *Queries) GetStats(ctx context.Context, arg GetStatsParams) (GetStatsRow, error) {
	row := q.db.QueryRow(ctx, getStats, arg.Column1, arg.Column2)
	var i GetStatsRow
	err := row.Scan(
		&i.TotalBooks,
		&i.ActiveUsers,
		&i.TotalSubscriptions,
		&i.RevenueMonth,
	)
	return i, err
}

const getSubscriptionHistory = `-- name: GetSubscriptionHistory :many
SELECT TO_CHAR(start_date, 'Mon') AS month,
       COUNT(*) FILTER (WHERE status='active') AS active,
       COUNT(*) FILTER (WHERE status='cancelled') AS cancelled
FROM subscriptions
WHERE start_date >= NOW() - INTERVAL '6 months'
GROUP BY month
ORDER BY MIN(start_date)
`

type GetSubscriptionHistoryRow struct {
	Month     string `json:"month"`
	Active    int64  `json:"active"`
	Cancelled int64  `json:"cancelled"`
}

func (q *Queries) GetSubscriptionHistory(ctx context.Context) ([]GetSubscriptionHistoryRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionHistoryRow
	for rows.Next() {
		var i GetSubscriptionHistoryRow
		if err := rows.Scan(&i.Month, &i.Active, &i.Cancelled); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionPlans = `-- name: GetSubscriptionPlans :many
SELECT sp.name AS plan,
       COUNT(s.id) AS count
FROM subscriptions s
JOIN subscription_plans sp ON s.plan_id = sp.id
WHERE s.status='active'
GROUP BY sp.name
`

type GetSubscriptionPlansRow struct {
	Plan  string `json:"plan"`
	Count int64  `json:"count"`
}

func (q *Queries) GetSubscriptionPlans(ctx context.Context) ([]GetSubscriptionPlansRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionPlansRow
	for rows.Next() {
		var i GetSubscriptionPlansRow
		if err := rows.Scan(&i.Plan, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopBorrowedBooks = `-- name: GetTopBorrowedBooks :many
SELECT b.title AS name,
       COUNT(*) AS count
FROM borrows br
JOIN books b ON br.book_id = b.id
GROUP BY b.title
ORDER BY count DESC
LIMIT 5
`

type GetTopBorrowedBooksRow struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

func (q *Queries) GetTopBorrowedBooks(ctx context.Context) ([]GetTopBorrowedBooksRow, error) {
	rows, err := q.db.Query(ctx, getTopBorrowedBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopBorrowedBooksRow
	for rows.Next() {
		var i GetTopBorrowedBooksRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
