// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: borrows.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveBorrowsByUserID = `-- name: CountActiveBorrowsByUserID :one
SELECT COUNT(*)
FROM borrows
WHERE user_id = $1
AND returned_at IS NULL
`

func (q *Queries) CountActiveBorrowsByUserID(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveBorrowsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllBorrows = `-- name: CountAllBorrows :one
SELECT COUNT(*) FROM borrows
`

func (q *Queries) CountAllBorrows(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllBorrows)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBorrowedAt = `-- name: CountBorrowedAt :one
SELECT COUNT(*) FROM borrows WHERE borrowed_at IS NOT NULL
`

func (q *Queries) CountBorrowedAt(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countBorrowedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBorrowedBooksByUserID = `-- name: CountBorrowedBooksByUserID :one
SELECT COUNT(*)
FROM borrows
WHERE user_id = $1
`

func (q *Queries) CountBorrowedBooksByUserID(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countBorrowedBooksByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNotReturnedAt = `-- name: CountNotReturnedAt :one
SELECT COUNT(*) FROM borrows WHERE returned_at IS NULL
`

func (q *Queries) CountNotReturnedAt(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countNotReturnedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReturnedAt = `-- name: CountReturnedAt :one
SELECT COUNT(*) FROM borrows WHERE returned_at IS NOT NULL
`

func (q *Queries) CountReturnedAt(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countReturnedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchBorrows = `-- name: CountSearchBorrows :one
SELECT COUNT(*)
FROM borrows b
JOIN books bk ON b.book_id = bk.id
JOIN users u ON b.user_id = u.id
WHERE 
    CASE 
        WHEN $1 = '' OR $1 = 'all' THEN TRUE
        ELSE 
            LOWER(u.first_name || ' ' || u.last_name) LIKE LOWER('%' || $1 || '%')
            OR LOWER(bk.title) LIKE LOWER('%' || $1 || '%')
    END
`

func (q *Queries) CountSearchBorrows(ctx context.Context, dollar_1 interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchBorrows, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBorrow = `-- name: CreateBorrow :one
INSERT INTO borrows (user_id,book_id,due_date,returned_at) VALUES ($1,$2,$3,$4)
RETURNING id, user_id, book_id, borrowed_at, due_date, returned_at
`

type CreateBorrowParams struct {
	UserID     pgtype.UUID      `json:"user_id"`
	BookID     pgtype.UUID      `json:"book_id"`
	DueDate    pgtype.Timestamp `json:"due_date"`
	ReturnedAt pgtype.Timestamp `json:"returned_at"`
}

func (q *Queries) CreateBorrow(ctx context.Context, arg CreateBorrowParams) (Borrow, error) {
	row := q.db.QueryRow(ctx, createBorrow,
		arg.UserID,
		arg.BookID,
		arg.DueDate,
		arg.ReturnedAt,
	)
	var i Borrow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
	)
	return i, err
}

const filterBorrowByUserAndBookID = `-- name: FilterBorrowByUserAndBookID :one
SELECT id, user_id, book_id, borrowed_at, due_date, returned_at FROM borrows WHERE user_id = $1 AND book_id = $2 AND returned_at IS NULL
`

type FilterBorrowByUserAndBookIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	BookID pgtype.UUID `json:"book_id"`
}

func (q *Queries) FilterBorrowByUserAndBookID(ctx context.Context, arg FilterBorrowByUserAndBookIDParams) (Borrow, error) {
	row := q.db.QueryRow(ctx, filterBorrowByUserAndBookID, arg.UserID, arg.BookID)
	var i Borrow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
	)
	return i, err
}

const listBorrow = `-- name: ListBorrow :many
SELECT id, user_id, book_id, borrowed_at, due_date, returned_at FROM borrows
ORDER BY due_date DESC
`

func (q *Queries) ListBorrow(ctx context.Context) ([]Borrow, error) {
	rows, err := q.db.Query(ctx, listBorrow)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Borrow
	for rows.Next() {
		var i Borrow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBorrowByBookID = `-- name: ListBorrowByBookID :many
SELECT brs.id, brs.user_id, brs.book_id, brs.borrowed_at, brs.due_date, brs.returned_at, b.title FROM borrows brs
JOIN books b ON b.id = brs.book_id
WHERE book_id = $1
ORDER BY due_date DESC
`

type ListBorrowByBookIDRow struct {
	ID         pgtype.UUID      `json:"id"`
	UserID     pgtype.UUID      `json:"user_id"`
	BookID     pgtype.UUID      `json:"book_id"`
	BorrowedAt pgtype.Timestamp `json:"borrowed_at"`
	DueDate    pgtype.Timestamp `json:"due_date"`
	ReturnedAt pgtype.Timestamp `json:"returned_at"`
	Title      string           `json:"title"`
}

func (q *Queries) ListBorrowByBookID(ctx context.Context, bookID pgtype.UUID) ([]ListBorrowByBookIDRow, error) {
	rows, err := q.db.Query(ctx, listBorrowByBookID, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBorrowByBookIDRow
	for rows.Next() {
		var i ListBorrowByBookIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBorrowByUserID = `-- name: ListBorrowByUserID :many
SELECT brs.id, brs.user_id, brs.book_id, brs.borrowed_at, brs.due_date, brs.returned_at, b.title
FROM borrows brs
JOIN books b ON b.id = brs.book_id  -- <- fix here
WHERE brs.user_id = $1
ORDER BY brs.due_date DESC
`

type ListBorrowByUserIDRow struct {
	ID         pgtype.UUID      `json:"id"`
	UserID     pgtype.UUID      `json:"user_id"`
	BookID     pgtype.UUID      `json:"book_id"`
	BorrowedAt pgtype.Timestamp `json:"borrowed_at"`
	DueDate    pgtype.Timestamp `json:"due_date"`
	ReturnedAt pgtype.Timestamp `json:"returned_at"`
	Title      string           `json:"title"`
}

func (q *Queries) ListBorrowByUserID(ctx context.Context, userID pgtype.UUID) ([]ListBorrowByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listBorrowByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBorrowByUserIDRow
	for rows.Next() {
		var i ListBorrowByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBorrowPaginated = `-- name: ListBorrowPaginated :many
SELECT b.id, b.user_id, b.book_id, b.borrowed_at, b.due_date, b.returned_at, bk.title AS book_title
FROM borrows b
JOIN books bk ON b.book_id = bk.id
LIMIT $1 OFFSET $2
`

type ListBorrowPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListBorrowPaginatedRow struct {
	ID         pgtype.UUID      `json:"id"`
	UserID     pgtype.UUID      `json:"user_id"`
	BookID     pgtype.UUID      `json:"book_id"`
	BorrowedAt pgtype.Timestamp `json:"borrowed_at"`
	DueDate    pgtype.Timestamp `json:"due_date"`
	ReturnedAt pgtype.Timestamp `json:"returned_at"`
	BookTitle  string           `json:"book_title"`
}

func (q *Queries) ListBorrowPaginated(ctx context.Context, arg ListBorrowPaginatedParams) ([]ListBorrowPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listBorrowPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBorrowPaginatedRow
	for rows.Next() {
		var i ListBorrowPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BookTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBorrowPaginatedByBorrowedAt = `-- name: ListBorrowPaginatedByBorrowedAt :many
SELECT 
    b.id, 
    b.user_id, 
    b.book_id, 
    b.borrowed_at, 
    b.due_date, 
    b.returned_at, 
    bk.title AS book_title, 
CONCAT(u.first_name, ' ', u.last_name)::TEXT AS user_name
FROM borrows b
JOIN books bk ON b.book_id = bk.id
JOIN users u ON b.user_id = u.id  -- ← Changed from bk.user_id to b.user_id
ORDER BY b.borrowed_at DESC
LIMIT $1 OFFSET $2
`

type ListBorrowPaginatedByBorrowedAtParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListBorrowPaginatedByBorrowedAtRow struct {
	ID         pgtype.UUID      `json:"id"`
	UserID     pgtype.UUID      `json:"user_id"`
	BookID     pgtype.UUID      `json:"book_id"`
	BorrowedAt pgtype.Timestamp `json:"borrowed_at"`
	DueDate    pgtype.Timestamp `json:"due_date"`
	ReturnedAt pgtype.Timestamp `json:"returned_at"`
	BookTitle  string           `json:"book_title"`
	UserName   string           `json:"user_name"`
}

func (q *Queries) ListBorrowPaginatedByBorrowedAt(ctx context.Context, arg ListBorrowPaginatedByBorrowedAtParams) ([]ListBorrowPaginatedByBorrowedAtRow, error) {
	rows, err := q.db.Query(ctx, listBorrowPaginatedByBorrowedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBorrowPaginatedByBorrowedAtRow
	for rows.Next() {
		var i ListBorrowPaginatedByBorrowedAtRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BookTitle,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBorrowPaginatedByNotReturnedAt = `-- name: ListBorrowPaginatedByNotReturnedAt :many
SELECT 
    b.id, 
    b.user_id, 
    b.book_id, 
    b.borrowed_at, 
    b.due_date, 
    b.returned_at, 
    bk.title AS book_title, 
CONCAT(u.first_name, ' ', u.last_name)::TEXT AS user_name
FROM borrows b
JOIN books bk ON b.book_id = bk.id
JOIN users u ON b.user_id = u.id
WHERE b.returned_at IS NULL
ORDER BY b.borrowed_at DESC
LIMIT $1 OFFSET $2
`

type ListBorrowPaginatedByNotReturnedAtParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListBorrowPaginatedByNotReturnedAtRow struct {
	ID         pgtype.UUID      `json:"id"`
	UserID     pgtype.UUID      `json:"user_id"`
	BookID     pgtype.UUID      `json:"book_id"`
	BorrowedAt pgtype.Timestamp `json:"borrowed_at"`
	DueDate    pgtype.Timestamp `json:"due_date"`
	ReturnedAt pgtype.Timestamp `json:"returned_at"`
	BookTitle  string           `json:"book_title"`
	UserName   string           `json:"user_name"`
}

func (q *Queries) ListBorrowPaginatedByNotReturnedAt(ctx context.Context, arg ListBorrowPaginatedByNotReturnedAtParams) ([]ListBorrowPaginatedByNotReturnedAtRow, error) {
	rows, err := q.db.Query(ctx, listBorrowPaginatedByNotReturnedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBorrowPaginatedByNotReturnedAtRow
	for rows.Next() {
		var i ListBorrowPaginatedByNotReturnedAtRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BookTitle,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBorrowPaginatedByReturnedAt = `-- name: ListBorrowPaginatedByReturnedAt :many
SELECT 
    b.id, 
    b.user_id, 
    b.book_id, 
    b.borrowed_at, 
    b.due_date, 
    b.returned_at, 
    bk.title AS book_title, 
CONCAT(u.first_name, ' ', u.last_name)::TEXT AS user_name
FROM borrows b
JOIN books bk ON b.book_id = bk.id
JOIN users u ON b.user_id = u.id  -- ← Changed from bk.user_id to b.user_id
WHERE b.returned_at IS NOT NULL
ORDER BY b.returned_at DESC
LIMIT $1 OFFSET $2
`

type ListBorrowPaginatedByReturnedAtParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListBorrowPaginatedByReturnedAtRow struct {
	ID         pgtype.UUID      `json:"id"`
	UserID     pgtype.UUID      `json:"user_id"`
	BookID     pgtype.UUID      `json:"book_id"`
	BorrowedAt pgtype.Timestamp `json:"borrowed_at"`
	DueDate    pgtype.Timestamp `json:"due_date"`
	ReturnedAt pgtype.Timestamp `json:"returned_at"`
	BookTitle  string           `json:"book_title"`
	UserName   string           `json:"user_name"`
}

func (q *Queries) ListBorrowPaginatedByReturnedAt(ctx context.Context, arg ListBorrowPaginatedByReturnedAtParams) ([]ListBorrowPaginatedByReturnedAtRow, error) {
	rows, err := q.db.Query(ctx, listBorrowPaginatedByReturnedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBorrowPaginatedByReturnedAtRow
	for rows.Next() {
		var i ListBorrowPaginatedByReturnedAtRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BookTitle,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBorrowsWithPagination = `-- name: SearchBorrowsWithPagination :many
SELECT 
    b.id, 
    b.user_id, 
    b.book_id, 
    b.borrowed_at, 
    b.due_date, 
    b.returned_at, 
    bk.title AS book_title,
    (u.first_name || ' ' || u.last_name) AS user_name
FROM borrows b
JOIN books bk ON b.book_id = bk.id
JOIN users u ON b.user_id = u.id
WHERE 
    ($1 = 'all' OR $1 = '' 
      OR ($2 = 'user_name' AND LOWER(u.first_name || ' ' || u.last_name) LIKE LOWER('%' || $1 || '%'))
      OR ($2 = 'book_title' AND LOWER(bk.title) LIKE LOWER('%' || $1 || '%'))
    )
ORDER BY b.borrowed_at DESC
LIMIT $3
OFFSET $4
`

type SearchBorrowsWithPaginationParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchBorrowsWithPaginationRow struct {
	ID         pgtype.UUID      `json:"id"`
	UserID     pgtype.UUID      `json:"user_id"`
	BookID     pgtype.UUID      `json:"book_id"`
	BorrowedAt pgtype.Timestamp `json:"borrowed_at"`
	DueDate    pgtype.Timestamp `json:"due_date"`
	ReturnedAt pgtype.Timestamp `json:"returned_at"`
	BookTitle  string           `json:"book_title"`
	UserName   interface{}      `json:"user_name"`
}

func (q *Queries) SearchBorrowsWithPagination(ctx context.Context, arg SearchBorrowsWithPaginationParams) ([]SearchBorrowsWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, searchBorrowsWithPagination,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchBorrowsWithPaginationRow
	for rows.Next() {
		var i SearchBorrowsWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.BookTitle,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBorrowReturnedAtByID = `-- name: UpdateBorrowReturnedAtByID :exec
UPDATE borrows
SET returned_at = NOW()
WHERE id = $1 AND returned_at IS NULL
`

func (q *Queries) UpdateBorrowReturnedAtByID(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateBorrowReturnedAtByID, id)
	return err
}
