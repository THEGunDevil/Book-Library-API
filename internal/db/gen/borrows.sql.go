// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: borrows.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBorrow = `-- name: CreateBorrow :one
INSERT INTO borrows (user_id,book_id,due_date,returned_at) VALUES ($1,$2,$3,$4)
RETURNING id, user_id, book_id, borrowed_at, due_date, returned_at
`

type CreateBorrowParams struct {
	UserID     pgtype.UUID
	BookID     pgtype.UUID
	DueDate    pgtype.Timestamp
	ReturnedAt pgtype.Timestamp
}

func (q *Queries) CreateBorrow(ctx context.Context, arg CreateBorrowParams) (Borrow, error) {
	row := q.db.QueryRow(ctx, createBorrow,
		arg.UserID,
		arg.BookID,
		arg.DueDate,
		arg.ReturnedAt,
	)
	var i Borrow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
	)
	return i, err
}

const filterBorrowByUserAndBookID = `-- name: FilterBorrowByUserAndBookID :one
SELECT id, user_id, book_id, borrowed_at, due_date, returned_at FROM borrows WHERE user_id = $1 AND book_id = $2 AND returned_at IS NULL
`

type FilterBorrowByUserAndBookIDParams struct {
	UserID pgtype.UUID
	BookID pgtype.UUID
}

func (q *Queries) FilterBorrowByUserAndBookID(ctx context.Context, arg FilterBorrowByUserAndBookIDParams) (Borrow, error) {
	row := q.db.QueryRow(ctx, filterBorrowByUserAndBookID, arg.UserID, arg.BookID)
	var i Borrow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BookID,
		&i.BorrowedAt,
		&i.DueDate,
		&i.ReturnedAt,
	)
	return i, err
}

const listBorrow = `-- name: ListBorrow :many
SELECT id, user_id, book_id, borrowed_at, due_date, returned_at FROM borrows
ORDER BY due_date DESC
`

func (q *Queries) ListBorrow(ctx context.Context) ([]Borrow, error) {
	rows, err := q.db.Query(ctx, listBorrow)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Borrow
	for rows.Next() {
		var i Borrow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBorrowByUserID = `-- name: ListBorrowByUserID :many
SELECT brs.id, brs.user_id, brs.book_id, brs.borrowed_at, brs.due_date, brs.returned_at, b.title FROM borrows brs
JOIN books b ON b.id = r.book_id
WHERE user_id = $1
ORDER BY due_date DESC
`

type ListBorrowByUserIDRow struct {
	ID         pgtype.UUID
	UserID     pgtype.UUID
	BookID     pgtype.UUID
	BorrowedAt pgtype.Timestamp
	DueDate    pgtype.Timestamp
	ReturnedAt pgtype.Timestamp
	Title      string
}

func (q *Queries) ListBorrowByUserID(ctx context.Context, userID pgtype.UUID) ([]ListBorrowByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listBorrowByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBorrowByUserIDRow
	for rows.Next() {
		var i ListBorrowByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.BorrowedAt,
			&i.DueDate,
			&i.ReturnedAt,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBorrowByUserAndBookID = `-- name: UpdateBorrowByUserAndBookID :exec
UPDATE borrows
SET returned_at = NOW()
WHERE user_id = $1 AND book_id = $2 AND returned_at IS NULL
`

type UpdateBorrowByUserAndBookIDParams struct {
	UserID pgtype.UUID
	BookID pgtype.UUID
}

func (q *Queries) UpdateBorrowByUserAndBookID(ctx context.Context, arg UpdateBorrowByUserAndBookIDParams) error {
	_, err := q.db.Exec(ctx, updateBorrowByUserAndBookID, arg.UserID, arg.BookID)
	return err
}
