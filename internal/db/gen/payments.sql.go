// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPayments = `-- name: CountPayments :one
SELECT COUNT(*) FROM payments
`

func (q *Queries) CountPayments(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPayments)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPaymentsByEmail = `-- name: CountPaymentsByEmail :one
SELECT COUNT(*)
FROM payments
WHERE
    (CASE
        WHEN $1 = '' THEN TRUE
        ELSE email ILIKE '%' || $1 || '%'
    END)
`

func (q *Queries) CountPaymentsByEmail(ctx context.Context, dollar_1 interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, countPaymentsByEmail, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    user_id,
    plan_id,
    amount,
    payment_gateway,
    currency
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, email, user_id, plan_id, subscription_id, amount, currency, transaction_id, payment_gateway, status, created_at, updated_at
`

type CreatePaymentParams struct {
	UserID         pgtype.UUID `json:"user_id"`
	PlanID         pgtype.UUID `json:"plan_id"`
	Amount         float64     `json:"amount"`
	PaymentGateway pgtype.Text `json:"payment_gateway"`
	Currency       string      `json:"currency"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.UserID,
		arg.PlanID,
		arg.Amount,
		arg.PaymentGateway,
		arg.Currency,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.UserID,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Amount,
		&i.Currency,
		&i.TransactionID,
		&i.PaymentGateway,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRefund = `-- name: CreateRefund :one



INSERT INTO refunds (
    id, payment_id, amount, reason, status, requested_at, processed_at
) VALUES (
    $1, $2, $3, $4, $5, NOW(), $6
) RETURNING id, payment_id, amount, reason, status, requested_at, processed_at
`

type CreateRefundParams struct {
	ID          pgtype.UUID      `json:"id"`
	PaymentID   pgtype.UUID      `json:"payment_id"`
	Amount      float64          `json:"amount"`
	Reason      pgtype.Text      `json:"reason"`
	Status      string           `json:"status"`
	ProcessedAt pgtype.Timestamp `json:"processed_at"`
}

// SELECT COUNT(*) FROM payments WHERE status = 'pending';
// SELECT COUNT(*) FROM payments WHERE status = 'failed';
// ===============================
// Refunds
// ===============================
func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (Refund, error) {
	row := q.db.QueryRow(ctx, createRefund,
		arg.ID,
		arg.PaymentID,
		arg.Amount,
		arg.Reason,
		arg.Status,
		arg.ProcessedAt,
	)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.RequestedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payments
WHERE id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePayment, id)
	return err
}

const deleteRefund = `-- name: DeleteRefund :exec
DELETE FROM refunds
WHERE id = $1
`

func (q *Queries) DeleteRefund(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRefund, id)
	return err
}

const getAllPayments = `-- name: GetAllPayments :many
SELECT id, email, user_id, plan_id, subscription_id, amount, currency, transaction_id, payment_gateway, status, created_at, updated_at FROM payments
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllPaymentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllPayments(ctx context.Context, arg GetAllPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getAllPayments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.UserID,
			&i.PlanID,
			&i.SubscriptionID,
			&i.Amount,
			&i.Currency,
			&i.TransactionID,
			&i.PaymentGateway,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, email, user_id, plan_id, subscription_id, amount, currency, transaction_id, payment_gateway, status, created_at, updated_at FROM payments
WHERE id = $1
`

func (q *Queries) GetPaymentByID(ctx context.Context, id pgtype.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.UserID,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Amount,
		&i.Currency,
		&i.TransactionID,
		&i.PaymentGateway,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByTransactionID = `-- name: GetPaymentByTransactionID :one
SELECT id, email, user_id, plan_id, subscription_id, amount, currency, transaction_id, payment_gateway, status, created_at, updated_at FROM payments
WHERE transaction_id = $1
`

func (q *Queries) GetPaymentByTransactionID(ctx context.Context, transactionID pgtype.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByTransactionID, transactionID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.UserID,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Amount,
		&i.Currency,
		&i.TransactionID,
		&i.PaymentGateway,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRefundByID = `-- name: GetRefundByID :one
SELECT id, payment_id, amount, reason, status, requested_at, processed_at FROM refunds
WHERE id = $1
`

func (q *Queries) GetRefundByID(ctx context.Context, id pgtype.UUID) (Refund, error) {
	row := q.db.QueryRow(ctx, getRefundByID, id)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.RequestedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const getRefundByPaymentID = `-- name: GetRefundByPaymentID :one
SELECT id, payment_id, amount, reason, status, requested_at, processed_at FROM refunds
WHERE payment_id = $1
`

func (q *Queries) GetRefundByPaymentID(ctx context.Context, paymentID pgtype.UUID) (Refund, error) {
	row := q.db.QueryRow(ctx, getRefundByPaymentID, paymentID)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.RequestedAt,
		&i.ProcessedAt,
	)
	return i, err
}

const getTotalSales = `-- name: GetTotalSales :one
SELECT COALESCE(SUM(amount), 0) AS total_sales
FROM payments
WHERE status = 'paid'
`

func (q *Queries) GetTotalSales(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, getTotalSales)
	var total_sales interface{}
	err := row.Scan(&total_sales)
	return total_sales, err
}

const listPaymentsByUser = `-- name: ListPaymentsByUser :many
SELECT id, email, user_id, plan_id, subscription_id, amount, currency, transaction_id, payment_gateway, status, created_at, updated_at FROM payments
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentsByUser(ctx context.Context, userID pgtype.UUID) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPaymentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.UserID,
			&i.PlanID,
			&i.SubscriptionID,
			&i.Amount,
			&i.Currency,
			&i.TransactionID,
			&i.PaymentGateway,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRefundsByPayment = `-- name: ListRefundsByPayment :many
SELECT id, payment_id, amount, reason, status, requested_at, processed_at FROM refunds
WHERE payment_id = $1
ORDER BY requested_at DESC
`

func (q *Queries) ListRefundsByPayment(ctx context.Context, paymentID pgtype.UUID) ([]Refund, error) {
	rows, err := q.db.Query(ctx, listRefundsByPayment, paymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Refund
	for rows.Next() {
		var i Refund
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Amount,
			&i.Reason,
			&i.Status,
			&i.RequestedAt,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRefundsByStatus = `-- name: ListRefundsByStatus :many
SELECT id, payment_id, amount, reason, status, requested_at, processed_at FROM refunds
WHERE status = $1
ORDER BY requested_at DESC
`

func (q *Queries) ListRefundsByStatus(ctx context.Context, status string) ([]Refund, error) {
	rows, err := q.db.Query(ctx, listRefundsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Refund
	for rows.Next() {
		var i Refund
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Amount,
			&i.Reason,
			&i.Status,
			&i.RequestedAt,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPaymentsByEmailWithPagination = `-- name: SearchPaymentsByEmailWithPagination :many
SELECT id, email, user_id, plan_id, subscription_id, amount, currency, transaction_id, payment_gateway, status, created_at, updated_at
FROM payments
WHERE
    (CASE 
        WHEN $1 = '' THEN TRUE
        ELSE email ILIKE '%' || $1 || '%'
    END)
ORDER BY email
LIMIT $2
OFFSET $3
`

type SearchPaymentsByEmailWithPaginationParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchPaymentsByEmailWithPagination(ctx context.Context, arg SearchPaymentsByEmailWithPaginationParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, searchPaymentsByEmailWithPagination, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.UserID,
			&i.PlanID,
			&i.SubscriptionID,
			&i.Amount,
			&i.Currency,
			&i.TransactionID,
			&i.PaymentGateway,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments
SET status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, email, user_id, plan_id, subscription_id, amount, currency, transaction_id, payment_gateway, status, created_at, updated_at
`

type UpdatePaymentStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentStatus, arg.ID, arg.Status)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.UserID,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Amount,
		&i.Currency,
		&i.TransactionID,
		&i.PaymentGateway,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentStatusByTransactionID = `-- name: UpdatePaymentStatusByTransactionID :one
UPDATE payments
SET status = $2,
    updated_at = NOW()
WHERE transaction_id = $1
RETURNING id, email, user_id, plan_id, subscription_id, amount, currency, transaction_id, payment_gateway, status, created_at, updated_at
`

type UpdatePaymentStatusByTransactionIDParams struct {
	TransactionID pgtype.UUID `json:"transaction_id"`
	Status        string      `json:"status"`
}

func (q *Queries) UpdatePaymentStatusByTransactionID(ctx context.Context, arg UpdatePaymentStatusByTransactionIDParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentStatusByTransactionID, arg.TransactionID, arg.Status)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.UserID,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Amount,
		&i.Currency,
		&i.TransactionID,
		&i.PaymentGateway,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentSubscriptionID = `-- name: UpdatePaymentSubscriptionID :one
UPDATE payments
SET subscription_id = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, email, user_id, plan_id, subscription_id, amount, currency, transaction_id, payment_gateway, status, created_at, updated_at
`

type UpdatePaymentSubscriptionIDParams struct {
	ID             pgtype.UUID `json:"id"`
	SubscriptionID pgtype.UUID `json:"subscription_id"`
}

func (q *Queries) UpdatePaymentSubscriptionID(ctx context.Context, arg UpdatePaymentSubscriptionIDParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentSubscriptionID, arg.ID, arg.SubscriptionID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.UserID,
		&i.PlanID,
		&i.SubscriptionID,
		&i.Amount,
		&i.Currency,
		&i.TransactionID,
		&i.PaymentGateway,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRefundStatus = `-- name: UpdateRefundStatus :one
UPDATE refunds
SET status = $2,
    processed_at = $3
WHERE id = $1
RETURNING id, payment_id, amount, reason, status, requested_at, processed_at
`

type UpdateRefundStatusParams struct {
	ID          pgtype.UUID      `json:"id"`
	Status      string           `json:"status"`
	ProcessedAt pgtype.Timestamp `json:"processed_at"`
}

func (q *Queries) UpdateRefundStatus(ctx context.Context, arg UpdateRefundStatusParams) (Refund, error) {
	row := q.db.QueryRow(ctx, updateRefundStatus, arg.ID, arg.Status, arg.ProcessedAt)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.RequestedAt,
		&i.ProcessedAt,
	)
	return i, err
}
